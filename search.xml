<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Learning Social Etiquette]]></title>
    <url>%2F2018%2F03%2F24%2FLearning-Social-Etiquette%2F</url>
    <content type="text"><![CDATA[Learning Social Etiquette:Human Trajectory Understanding in Crowded Scenes 论文发表在ECCV2016上，引用31次。 公布了一个大型数据集(包含了各种目标，人、自行车、公交车...)(http://cvgl.stanford.edu/projects/uav_data/)。 包含了100多种不同的场景，20000个目标。包含了大量的 target-target interaction(185K) 和 target-space interaction(40K). 如上图所示，数据采集场景被划分为了6个部分。 Modeling Social Sensitivity 通过能量势能(energy potential)建模对象之间的相互作用，高的能量势能表明更敏感。 在每一个时刻 t, 第 i 个对象的状态表示为 \(s_i^{(t)}=\{p_i^{(t)},v_i^{(t)}\}\). 分别代表位置和速度(矢量)。建模social sensitivity 的能量势能定义如下： 其中，\(w(s_i, s_j)\)和\(d^2(v, s_i, s_j)\) 分别定义为 上面的式子是从 You'll never walk alone中拿过来的。在原来的文章里，\(E_{ss}\)用来衡量人与人之间交互产生的能量势能。 本文定义参数\(\Theta_{ss}=\{\sigma_d,\sigma_w,\beta\}\)作为社交敏感度特征(social sensitivity feature)。它们描绘了对象之间是如何避免碰撞的，其中： \(\sigma_d\) is the preferred distance a target maintains to avoid collision. \(\sigma_{w}\) is the distance at which a target reacts to prevent a collision(distance at which he starts deviating from its linear trajectory). \(\beta\) controls the peakiness of the weighting function. 这里的两个参数,一个表示行人之间开始受影响的距离,一个表示必须要采取措施避免碰撞的距离。 Training： 由于不同的对象在不同的环境下，可能存在不同的导航模式(navigation style)。如下图所示： 上图中间表示了4中不同的 navigation style(图中四种不同的颜色)，图中的每个点代表一个对象。横轴表示\(\sigma_d\)，纵轴表示\(\sigma_w\)。可以看到，右上角绿色的行人很远就开始改变方向(mild behavior)；而左下角红色的人知道要碰撞之前才开始改变防线(aggressive behavior)。 从上可知，对所有行人都使用一组参数\(\Theta_{ss}\)不能够刻画运动模式。本文采用的方法是，在训练过程中，对每一个对象解如下方程： 得到其 social sensitivity feature. 然后做 k-means 聚类，每一种类别代表一种导航模式。(这里我不知道他是如何对每一个对象求式4的，因为要同时求出三个未知数) 在测试阶段，对研究对象i 求下式最小： 然后得出了\(\Theta_{ss}(i)=\{\theta_d(i),\theta_w(i),\beta(i)\}\).将其分配到训练阶段得到的某个类中去，就得到了对象i 所属的导航模式。 论文也讨论了，对象在运动过程中，随着周围环境的变化，其导航模式也可能发生变化(这个变化与其物理类型无关). 上面的四个图分别代表了四个时刻，同一种颜色代表了同一种 navigation style。 ### 预测行人的轨迹： 给定观测对象过去 t 个时刻的轨迹，希望预测未来 N 个时刻的位置。 对于每一个对象来说，其能量函数定义为： 上式来自who are you with and where are you going(CVPR2011)。\(\Theta=\{\lambda_0(c),\lambda_1(c),\lambda_2(c),\lambda_3(c),\lambda_4(c),\sigma_d(v^t),\sigma_w(v^t),\beta\}\), c 代表navigation style.本文的做法是对对象使用 5 式得到\(\sigma_d\)，\(\sigma_w\)，然后确定其属于的 navigation style。对于属于同一 navigation style 的对象，共享所有其他参数。通过这种方法，极大地提高了计算效率。 评价指标： 计算下列三种情况下的平均错误率：(1) the full estimated trajectory, (2) the final estimated point, (3) the average displacement during collision avoidance's.]]></content>
      <tags>
        <tag>papers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Who are you with and Where are you going?]]></title>
    <url>%2F2018%2F03%2F24%2FWho-are-you-with-and-Where-are-you-going%2F</url>
    <content type="text"><![CDATA[Who are you with and Where are you going? 论文发表在CVPR2011上,引用次数219次。 本文的贡献在于建立了一个能量函数，将各种影响行人运动的因素(personal、social、environment)综合考虑。明确的考虑了可能影响行人运动的隐含变量(hidden factors): 1. desired grouping behavior(who a person is trying to walk with); 2. the pedestrian's desired destination. 并且通过data-driven的方式估计隐含变量。 能够有效估计行人运动的终点，以及行人之间的social relationships(groups). Behavioral model An energy function for pedestrian navigation: The energy function for every pedestrian expresses the desirability of possible directions of motion for the pedestrian. 在每个时刻 \(t\), 第 \(i\) 个行人的状态表示为 \(s_i^{(t)}=(p_i^{(t)}, v_i^{(t)}, u_i^{(t)}, z_i^{(t)}, A_i^{(t)})\). 前四个变量依次表示：位置、速度(矢量)、preferred speed(标量), 终点。\(A_i\)表示包括 \(i\) 在内的一个social group中的所有行人. 由于\(u_i^{(t)}\), \(z_i^{(t)}\), \(A_i\)都是不可观测的，将这三个变量视为常量(time-invariant)。与You'll never walk alone (ICCV09) 中相同,模型预测下一个时刻的速度\(v_i^{(t+\Delta t)}\). 能量函数定义如下： 其中，\(\Theta = {\lambda_0,\lambda_1,\lambda_2,\lambda_3,\lambda_4,\sigma_d,\sigma_w,\beta}\) 为参数。\(s_{A_i}\) 表示第 \(i\) 个行人的 social group中所有行人的状态集合。\(s_{-i}\) 表示其他人的状态集合。 阻力项 (Damping): 惩罚速度的突变, \[E_{damping}(v; s_i) = |v - v_i|^2\] 速率项 (Speed): 惩罚速率偏离 preferred speed \(u_i\), \[E_{speed}(v; s_i) = (u_i - |v|)^2\] 方向项 (Direction): 通过\(-cos\)函数控制行人的速度方向朝向目的地 \(z_i\)， \[E_{direction}(v;s_i) = -\frac{z_i-p_i}{|z_i-p_i|} \cdot \frac{v}{|v|}\] 人群之间的吸引 (Attractin): People in the same group tend to stay close to each other while moving together. 上式中，$p_{ij} = p_i - p_j $。第二项惩罚 \(v\) 的方向远 离第\(j\)个行人。第一项考虑\(v_i\)和\(v_j\)此时的夹角。 Grouping: 同一个group里的人倾向于以相似的速度和方向移动， 避免碰撞， 这一项是直接从You'll never walk alone中拿过来的。 Dynamic model 第\(i\)个行人从 \(t\) 到 \(t+\Delta t\) 的状态转移为： 在训练过程中，当对一个行人的行为预测时，保持其他人的状态为ground-truth。用 \(\tilde{s_i}\) 表示ground-truth。学习的过程为： 模型中包含三个不可观测的量。分别是: preferred speed、destination、social groups. 其中： 1. 设置preferred speed 为之前所有时刻的平均速度。 2. 将 \(K\) 个可能的目的地表示为：\({Z_1,Z_2,Z_3,...,Z_K}\), 行人 \(i\) 之前的状态信息表示为: \(r_i^{(t)}=\{s_i^{(t&#39;)}\}_{t&#39;\leq t}\), 通过一个特征函数\(f_{dest}(r_i^{(t)})\)表示状态信息，用一个线性SVM预测可能的目的地。\[\check{z_i}^{(t)} = C_{dest} (f_{dest}(r_i^{(t)}))\] 3. 需要预测两个行人 \(i\) 和 \(j\) 是否属于同一个group。 给定两个行人之前的状态\((r_i^{(t)},r_j^{(t)})\), 判断他们是否属于同一个group(\(y_{ij}\in \{+1,-1\}\)).通过一个SVM分类器来解决这个二分类问题。\[\tilde{y}_{ij}=C_{group}(f_{group}(r_i^{(t)},r_j^{(t)}))\] \(f_{group}\)表示feature function.预测出来的social group为：\[\tilde{A_i}=\{j|\check{y}_{ij}=\pm1,j\neq i\}\cup\{i\}\] 特征表示的方法如下： ### Evaluation 实验首先评估了预测目的地、Social group的精度、查准率、查全率。 \(N_{past}\)表示考虑过去多少步的状态信息。结论：目的地的预测十分依赖于场景，而\(N_{past}\)基本不影响。而social-group的预测需要\(N_{past}\)的信息。 然后实验验证了，预测出来的行人位置与groud-truth之间的平均位移。预测的结果如下： 上图中, LIN代表恒定速度模型，LTA 代表You'll never walk alone 中的模型(目的地为ground-truth)。LTA+D 表示与LTA 相同的模型，但是目的地是预测出来的。ATTR代表本文的模型(目的地和social group 为ground-truth)，ATTR+D表示目的地是预测的，ATTR+G 表示Social-group 是预测出来的。ATTR+DG 表示完全用预测出来的。可以看到ATTR+DG 比LTA 结果要好。]]></content>
      <tags>
        <tag>papers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[You'll Never Walk Alone]]></title>
    <url>%2F2018%2F03%2F23%2FYou-ll-Never-Walk-Alone%2F</url>
    <content type="text"><![CDATA[You'll Never Walk Alone: Modeling Social Behavior for Multi-target Tracking 论文发表在 ICCV2009上，引用558次。 文章提出了一个LTA(Linear Trajectory Avoidance)模型，来建模短期行人的行为。(The model is designed for walking people with short-term prediction in mind). Modeling Social Behavior: 使用\(s_i = (p_i^t, v_i^t)\) 表示第\(i\)个行人的状态。其中，\(p_i^t\)表示二维平面上的位置，\(v_i^t\)表示第\(i\)个时刻的速度(矢量)。模型根据当前时刻所有对象的位置及速度预测下一个时刻每个人的速度。 假设每个行人都知道其他行人此刻的位置及速度。并且，每个行人都预测其他行人会保持当前的运动状态。假设行人\(s_i\)在当前时刻的速度为\(\tilde{v}_i\)，则他与行人\(s_j\)在时刻\(t\)的距离平方为\(d_{ij}^2(t)\)为： \[d_{ij}^2(t,\tilde{v_i})=\|p_i+t\tilde{v_i}-p_j-tv_j\|\] 这里\(d_{ij}\)依赖于\(\tilde{v_i}\)，表明正在使用\(s_i\)的视角。 定义 \(k_{ij}^t = p_i^t-p_j^t\), \(q_{ij}^t =\tilde{v}_i-v_j^t\), 则可以将上式重写为：\[d_{ij}^2(t,\tilde{v_i})=\|k+ tq\|^2\] 由于\(s_i\)对\(s_j\)的速度有一个估计，因而\(s_i\)会调整他的速度使得两人的最小距离\({d_{ij}^*}^2\)大于某个阈值(comfortable distance)。假设在时刻\(t^*\)，\(s_i\)和\(s_j\)的距离达到这个阈值:\[t^*= \underset{t&gt;0}{\arg\min}\ d_{ij}^2(t,\tilde{v}_i)\] 由于\(d_{ij}^2(t,\tilde{v_i})\)是\(t\)的二次函数，将其对\(t\)求偏导,并令其等于\(0\)得到：\[\frac{\partial{d_{ij}^2(t,\tilde{v}_i)}}{\partial{t}}=2(k+ {tq})q^{\top}=0 \rightarrow t^*=-\frac{k \cdot {q}}{\|q\|^2}\] 将\(t^*\)带入到第三步中，即可得到最近距离: \[{d_{ij}^*}^2(\tilde{v_i})=\|k-\frac{k\cdot{q}}{\|q\|^2}q^{\top}\|^2\] (\({d_{ij}^*}^2(\tilde{v_i})\) is the expected minimum distance between pedestrian \(i\) and \(j\) under a constant-velocity assumption)，由于是以\(s_i\)的视角来看待这个问题，因而假定\(s_j\)的各个属性是已知的。\({d_{ij}^*}^2(\tilde{v_i})\)是一个关于\(s_i\)当前速度\(\tilde{v_i}\)的函数. 为了确保\(s_i\)和\(s_j\)能够避开，可以给上式指定一个值。但是当存在多个行人时，这种做法不太方便。因而为了建模多个行人之间的互相作用，可以使用能量函数 \(E_{ij}\) 来表示行人 \(s_i\) 和 \(s_j\) 之间的相互作用。这个能量函数是 \({d_{ij}^*}^2\) 的函数: \[E_{ij}(\tilde{v}_i) = e^{ -\frac{ {d_{ij}^*}^2(\tilde{v_i})} {2\sigma_d^2}} \] 上式中\(\sigma_d\)控制到要避免的对象的距离(是一个要从数据中学习的参数)。当两个对象将要相撞时，\(E_{ij}\)变大;当\({d_{ij}^*}^2\)越来越大是，\(E_{ij}\)很小. 通过上式，多个行人对\(s_i\)的影响可以建模为加权和。对每个对象\(s_r(r\neq i)\),基于他当前的位置和与\(s_i\)的夹角\(\phi\)，分配一个权重\(w_r(i)\): \(w_r(i)=w_r^d(i)w_r^\phi(i)\) \(w_r^d(i)=e^{-\frac{\|k_{ir}\|^2}{2\sigma_w ^2}}\) \(w_r^{\phi}=((1+cos(\phi))/2)^{\beta}\) 其中，\(\sigma_w\)定义其他对象的影响半径。\(\beta\) 控制视野权重项的峰值。 对于\(s_i\)来说，其所有的相互作用能量(overall interaction energy)表示为: \[I_i(\tilde{v_i})=\sum_{r\neq i} {w_r(i)E_{ir}(\tilde{v_i})}\] 以上只讨论了行人之间的相互影响，没有考虑环境信息。因此，假设每一个行人都有一个目的地 \(z_i\), 并且行人倾向于保持一个速度\(u_i\)(desired speed)。这两个因素可以被表示为两个energy potentials.\[S_i(\tilde{v_i})=(u_i-\|\tilde{v_i}\|)^2$ $D_i(\tilde{v_i})=-\frac{(z_i-p_i)\cdot\tilde{v_i}}{\|z_i-p_i\|\cdot \|\tilde{v_i}\|}\] \(s_i\)所有的能量(energy)可以被表示为: \(E_i(\tilde{v_i})=I_i(\tilde{v_i})+\lambda_1S_i(\tilde{v_i})+\lambda_2D_i(\tilde{v_i})\) \(\lambda_1\)和\(\lambda_2\)为权重。要解决的问题就是求出当\(E_i(\tilde{v_i})\)取最小值时，对应的速度\(\tilde{v_i}\).(求解方法是梯度下降法) 上图为能量的示意图。黑色虚线代表当前的方向，\(c_1\)和\(c_2\)代表下一时刻可能的位置。品红色点代表当前的速度(矢量),白色点表示能量最少的速度(矢量)。 下图示意的是当\(s_1\)遇到两个行人\(s_2\)和\(s_3\)，其能量图。中间的图纵轴\(d_{23}\)表示两个行人\(s_2\)和\(s_3\)之间的距离。从图的下方可以看到，当\(S_2\)和\(s_3\)相聚较远的时候，中间的能量较低，表明\(s_1\)可以从两人中间走过。在图片上方，\(s_1\)只能绕开\(s_2\)和\(s_3\)。 通过使能量函数最小化，可以计算下一个期望速度\(\tilde{v_i^*}\)。由于惯性的作用，对象必须经过一个转换过程。对象下一时刻的位置为: \(p_i^{t_N}=p_i+(\alpha_N v_i+(1-\alpha_N)\tilde{v_i^*})t_N\) N为预测的间隔。\(\alpha\)是一个混合系数。 对于静止的障碍。将它们视为速度为0，并且以此刻障碍上距离行人最近的点作为障碍的位置。 模型的应用：给定\(t\)时刻的环境,通过最小化11式的能量函数，依次推测每 个行人\(t+1\)时刻的最优速度。然后将结果带入到13式中。一旦所有人的速度都已经确定后，同时更新。 ## Training 模型总共包含了6个参数需要学习，\({\sigma}_d\)定义了comfortable distance; \({\sigma}_w\)定义了radius of interest; 另外还有参数\(\beta\)，权重\(\lambda_1\)、\(\lambda_2\).系数\(\alpha\)。在每一轮迭代中，每个对象依次模拟，同时保持其他对象ground-truth. 得出的参数表明，大约1m 是comfortable 的分界，6m 会影响行人的运动。 Prediction 在每一个步中，使用预测地点和ground truth 之间的平均欧拉距离作为衡量标准。作为对比的模型是：匀速模型LIN；社会力模型；完整的LTA模型；以及在训练过程中，不使用行人之间相互作用，得到的一个模型DEST(仅包含目的地项的模型) 上图中，比SF和DEST 好6%,比LIN好24%.为了更清楚的比较模型之间的差异，可以观察错误的分布。为此，作如下定义: 若预测出来的位置和ground-truth 之间的距离小于一个阈值，就认为正确。左图横轴表示阈值。可以看到，在阈值为1m的时候，预测的准确率接近75%。右图是预测的示意图。]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Understanding Pedestrian Behaviors(CVPR2015)]]></title>
    <url>%2F2018%2F03%2F10%2FUnderstanding-Pedestrian-Behaviors-CVPR2015%2F</url>
    <content type="text"><![CDATA[Understanding Pedestrian Behaviors from Stationary Crowd Groups 论文发表在CVPR2015上（一作:Shuai Yi）。 论文的主要工作是：建立了一个行人运动(pedestrian behavior)的模型，其中，对静态人群是分析是关键部分。模型可以用来预测行人的轨迹；预测行人运动的终点；以及对人群中行人的运动行为分析。 论文的方法： 相关研究发现：静止的人群(stationary crowd groups)对行人运动的影响大于运动的人群(moving crowds)。(当运动的行人遇到运动的人群时, 行人一般只会减速，而当遇到静止的人群时，通常会改变方向)。 如上图所示：场景中的静止人群既可以作为（单个人）运动的终点和起点，也可以作为障碍物或者通道。 由于静止人群的位置分布(spatial distribution)可能随时间变化，因而引入了动态特征(dynamic variations of trafﬁc patterns)。而且当行人遇到静止人群时，即可能绕开人群，也可能穿过人群。论文建模了这些情况。 Pedestrian Behavior Modeling 行人通常会选择最方便、最有效的路径到达目的地。文章提出了一个“通用场景能量图”(general scene energy map), 来表示场景中不同位置的travel difficulty。能量越高的地方表示行人越愿意经过这些地方，因而，在能量高的地方观测到行人的概率也越大。 通用能量图建模(General energy map modeling) 通用能量图从三个方面来建模：1. 场景布局 \(f_{SL}\)；2.移动的行人\(f_{MP}\); 3. 静止的人群 \(f_{SG}\)。 其中，\(\theta_1,\theta_2,\theta_3,\theta_4\)不同项的权值向量。各项的表达式如下所示： 1.场景因素： 一般情况下，越是离障碍物近的地方，行人越不可能去。 上式中，\(SL\)代表障碍物占据的位置，\(d_1(x,SL)=min_{y\in{SL}}\parallel x-y \parallel_2^2\) 衡量当前位置\(x\)与最近的障碍物距离。\(x\) 越靠近障碍物，\(f_{SL}\)的值越小。 2.移动行人的影响： 行人总是与其他行人保持一定的距离，因此，行人周围地点的能量值较低。 上式中，\(MP_i\) 代表第\(i\)个移动的行人，\(x_t^{MP_i}\)是\(MP_i\)在当前时刻\(t\)的位置，\(x_{t+1}^{MP_i}\)是估计出来\(t+1\)时刻的位置。\(d_2(x,MP_i)=(\parallel x-x^{MP_i}_t\parallel +\parallel x-x^{MP_i}_{t+1} \parallel )^2 - (\parallel x_t^{MP_i} - x_{t+1}^{MP_i}\parallel)^2\),衡量当前位置\(x\)到移动的行人\(MP_i\)的距离。(这个距离度量来自social-force model)。 3.静止人群的影响： 对于绕过人群的行人来说，静止的人群可以视为障碍物(等同于场景因素)；对于穿过人群的行人，需要根据人群的密度不同，设置不同的罚项。 其中，\(SG_i\)是第\(i\)个静止的人群区域。\(d_3(x,SG_i)=min_{y\in{SG_i}}\parallel x-y \parallel^2_2\)衡量\(x\)到\(SG_i\)区域的距离。\(d_4(SG_i)\)衡量人群 \(SG_i\) 的稀疏性(\(d_4\)计算人群中行人之间的平均距离)。当\(x\in SG_i\)时，\(d_3(x,SG_i)=0\). 个性化能量图(Personalized energy map modeling) 在相同的环境下，不同的行人也可能有不同的走法，通过设置一个个性化因子\(P\)来建模. 若\(P\)值较大，则对于这个人来说，通用能量图中的所有因子\(\theta_1,\theta_2,\theta_3\)将同比例增大，此时，障碍物、行人、静止的人群周围的能量值都将下降，因而，此行人将走更远的路，来避免接触到这些障碍物。而当\(P\)值较小时，此人较少关注这些障碍物(walking aggressively and cares less about obstacles.) 路径生成的过程 给定起始点\(x_s\)和终点\(s_d\)，可以基于能量图M(或者个性化能量图\(M_P\))，通过Fast Marching算法得到最优路径。 此时得到的\(\hat{T}\)是当前能量图下最可能、最有效的路线。 模型的学习 能量图中某一点的能量表示了在这点观察到行人的概率。因此，模型的参数可以通过最大化似然函数得到。通过一个归一化项\(Z(\theta)\)，得到： 其中，\(Z(\theta)= \int M(x;\theta)dx\)。 对于给定的K个观测点\(x_1,x_2,...,x_k\)，观测到序列\(X=\{x_1,x_2,...,x_k\}\) 的似然函数为： 因而参数\(\theta\)可以通过下式得到： 通过梯度下降法迭代更新参数： 行人的路线预测： 定义一个over-cost值 \(\eta\) 来衡量预测结果和ground-truth的匹配程度。 上式中\(C(T_O,M)\)是基于当前能量图,由实际观测到的路线产生的cost。而\(C(\hat{T},M)\)是基于最优路线\(\hat{T}\)产生的花费。由于\(C(T_O,M) &gt; C(\hat{T},M)\)。因而\(\eta\)越小，表示匹配的越好。 结果： 行人运动终点预测： 给定起点\(x_s\)和部分轨迹\(T\)，可以预测终点位置： 方法是：输入起点和前半部分轨迹，对于10个终点位置\(S_i\)，计算 其中，\(\hat{T_{0.5}}(x_d&#39;)\)是\(\hat{T}(x_d&#39;)\)的前半部分，而\(\hat{T}(x_d&#39;)=f_{FM}(M, x_s, x_d&#39;)\)表示从\(x_s\)出发到\(x_d&#39;\)的最优路线，\(D(·,·)\)表示两条轨迹之间的距离， top_n 的预测结果如下： 原文中还包括对\(P\)值的探讨，以及通过\(P\)值将人群分类(方法还是通过最小化预测轨迹和观测轨迹的差距)。这里不再介绍。]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pedestrian Behavior Understanding and Prediction with Deep Neural Networks]]></title>
    <url>%2F2018%2F03%2F10%2FPedestrian-Behavior-Understanding-and-Prediction-with-Deep-Neural-Networks%2F</url>
    <content type="text"><![CDATA[Pedestrian Behavior Understanding and Prediction with Deep Neural Networks 论文发表在ECCV2016，使用深层神经网络理解并预测行人运动行为。(一作：Shuai Yi) 论文的核心思想：通过一种编码方案(encoding scheme)，使得行人的运动轨迹适合作为CNN的输入与输出。 论文的贡献： 用深层卷积网络(deep-CNN)建模了行人长期运动行为(Long-term pedestrian behaviors)，并对得到的CNN的结构进行了分析。 提出了一个行人运动行为的编码方案(pedestrian behavior encoding scheme), 将行人的运动路径编码为“稀疏位移量”(sparse displacement volumes)。后者可以直接作为深层网络的输入和输出。 论文的方法： 上图所示为总体的框架: 系统的输入为前几帧行人运动轨迹(图a 中的带颜色曲线)；然后将它们编码 为位移量(displacement volume)，如图 b 所示；将编码之后的量输入到Behavior CNN 中，网络的输出也为displacement volume，然后通过解码操作得到未来的预测估计。 运动轨迹编码： 如上图所示为编码过程。 令 \(p_1,p_2,...,p_N\)代表场景中的\(N\)个行人, \(t_1,t_2,...,t_m\)代表\(m\) 个时刻，其中\(t_m\)代表当前时刻。在时刻\(t_m\)，行人 \(p_i(i\in[1,N])\) 的归一化空间位置记为\(l_i^m=[x^m_i/X, y^m_i/Y]\)。其中，\(x_i^m\in[1,X]\), \(y_i^m\in[1,Y]\) 为空间坐标，\([X,Y]\) 为输入帧的空间大小(spatial size)。所有的位置都是基于网格的。 使用一个 \(2M\) 维的位移向量\(d_i=[l_i^M-l^1_i ,l^M_i- l_i^2,...,l_i^M-l_i^{M-1},l_i^M-l_i^M]\) 表示之前\(M\)帧，行人 \(p_i\) 的轨迹信息。\(d_i \in (-1,1)\). 基于\(d_i\)构建一个三维的位移量tensor \(D\in R^{X\times Y\times 2M}\)。对于每一个行人 \(p_i\) ，若其当前所在时刻的位置\((x_i^M, y_i^M)\)，则令 \(D(x_i^M,y_i^M,:) = d_i\)。为了区分含有静止行人和没有行人的位置(格子)，对所有含有行人的位置的 \(d_i+\textbf{1}^T\)。即 \(D(x_i^M, y_i^M,:)=d_i+ \textbf{1}^T\)。此时，含有人的格子，其\(2M\)个向量元素取值范围 \(\in(0,2)\), 静止行人为 1 ，\(D\) 中的其余部分均设置为 0。 CNN 模型 CNN 的输入为\(D\in R^{X\times Y \times 2M}\)，输出为 \(D^* \in R^{X\times Y \times 2M^*}\). 经过前三个卷积层操作之后的输出大小为 \(X\times Y \times 64\)。(为了保证feather map 的大小不变，中间有zero pad 操作) 经过max-pool 操作之后(stride 为2)，输出大小为\(X/2 \times Y/2 \times 64\)。 设置一个可学习的位置偏差图(location bias map)，其大小为\(X/2 \times Y/2\)。然后将这个位置偏差图 channel-wisely (总共有64个channel)加到 pool 之后得到的feather map 上。这样，每一个位置都有一个独立的偏差值(bias)，这个值在相同位置的所有通道上共享。 这个 location bias map 表示了环境信息。 之后是三个卷基层，再接着是一个逆卷积层，得到\(D^*\). 损失函数和训练： 损失函数计算预测得到的位移量和实际的位移量的\(L_2\)范数平方，定义为： 其中， \(\hat{D^*}\) 代表预测得到的位移量(displacement volume)；\(D^*\) 代表 ground-truth 的位移量。中间的点乘代表Hadamard product(哈达玛积，矩阵中对应元素相乘),\(M\) 是一个binary mask，当\(D^*\)为0 时，\(M=0\)。( \(D^*\) 为 0 的 entry 代表在时刻\(t_m\)，该位置没有行人) 由于输入数据非常稀疏，网络很容易陷入局部极小值，因此，文章采用了分层训练的方式。首先，训练一个随机初始化的三层卷积网络直到收敛，然后将这三层网络作为模型的\(conv1\)、\(conv2\)、\(conv3\)。之后加入后面的网络，联合训练。 实验结果： 采用MSE准侧函数来衡量预测结果。(文章在实现中，设置\(X=Y=256\)，而且文章没有提到对数据的预处理). 对预测的\(M^*\)个时刻，计算预测出来的归一化位置和归一化的ground-truth之间的\(L_2\)距离。 上式中: \(\hat{l}_i^{M+m}=[x_i^{M+m}/x, y_i^{M+m}/y]\)是归一化的位置。 Investigations on Behavior-CNN 对模型的一些实验解释 文章试验了有或者没有 Location bias map 对预测结果的影响。以及环境信息是否对网络预测结果有影响。 上图中的实例说明，论文提出的网络结构能够学习到位置信息以及环境信息。(a~c)说明了网络能够捕获不同区域不同的运动模式. 下图展示了不同的滤波器学到的内容： 图(a)分布表示第一个卷积层的33、59号滤波器得到的feather map。图(b)所示为图(a)上的高响应点的轨迹。(红点代表当前位置),可以看到filter 33能够找出向下移动的行人，而filter 59可以识别向上移动的行人。层数越高的滤波器越能更好的识别某一类轨迹的行人。(图d、图e) 对于高层次的卷积(conv4~conv6)，越能捕获复杂的运动模式。上图(f)表示第四层的filter 19能够捕获静止的行人。 论文还讨论不同的网络结构对预测结果的影响。尤其是感受野(Receptive Fields，表明了考虑与当前行人多元范围内的行人，论文使用的是场景大小的10%)的大小对性能的影响（所以，本文的模型使用了pool层，通过pool层，使得在网络参数个数相同时，感受野为2倍）。 结果展示： 上图中，绿色是ground-truth,红色是预测出来的。蓝色是走过的。 应用： 行人运动目的地预测。 作为先验知识提高Tracking算法的效果。]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Social LSTM]]></title>
    <url>%2F2018%2F03%2F10%2FSocial-LSTM%2F</url>
    <content type="text"><![CDATA[Social LSTM:Human Trajectory Prediction in Crowded Space 论文发表在CVPR2016上(spotlight)(一作：Alexandre Alahi)。 论文的核心思想： 将行人的轨迹预测问题看作是序列生成问题，对每一个行人使用一个LSTM网络。并且对于空间上临近的行人，引入了一个“Social pooling”层。通过这个&quot;Social pooling&quot;层，使得临近的行人能够共享他们的隐含状态 (这里的隐含状态指每个轨迹的LSTM中的隐含状态)。 论文的创新点：完全的 data-driven 方式，没有人工提取的特征，没有设计的吸引力和排斥力(social force model)；同时考虑了相关的多个序列；建模了不同序列之间的相关性。 论文的方法： 问题规约： 对于时刻 \(t\)，\(i^{th}\) 的坐标为\((x_t^i ,y_t^i )\)。已经知道了行人时刻 1 到时刻 \(T_{obs}\)的坐标，希望知道\(T_{obs+1}\) 到 \(T_{pred}\) 的坐标。 如上图所示，在每一个time-step，LSTM cell 从临近的LSTM cell接受 共享的隐含状态信息(pooled hidden-state information),得到一个三维的tensor(前两维为平面坐标，第三个维度是隐含状态)。 1. LSTM 的隐含状态 \(h\)\(_{i}^t\)捕获在时刻 t，第 i 个行人的隐含状态(latent representation)。 2. 通过构建隐含状态张量(&quot;Social&quot; hidden-state tensor) \(H\)\(_{i}^t\)与邻居共享行人隐含状态： 给定隐含状态维度为\(D\)，邻居大小(即考虑范围)为\(N_0\)，对第 \(i\) 个行人的轨迹构建一个 \(N_0\times N_0 \times D\) 的tensor: 上式中： * \(h\)\(_{t-1}^j\) 是第 j 个行人在时刻 t-1 对应的LSTM 隐含状态。 * \(1_{mn}[x, y]\)是指示函数，检查 \((x, y)\)是否在\((m, n)\)表示的方格内部。 * \(\mathscr{N}\)\(_i\) 是第 \(i\) 个行人的邻居集合。 如下图所示为黑色点代表的行人的Social-pooling 上图中表示在某个特定的空间距离内(即上式中表示的N0)的存在三个邻居，分别用黄色、蓝色、橘色表示。 结合上图，可以理解方程(1)的含义： 首先，确定第 \(i\) 个行人周围某个范围内的行人集合，然后以当前考虑行人为中心，确定各个邻居落在那个方格内，对于落在相同格子里的人，将其隐含状态相加。(上图中的示例 \(N_0\)等于\(2\)，而实验中实际\(N_0\)取的是32),得到tensor. 3.将张量\(H_t^i\)映射(embed)到向量 \(a_t^i\), 将坐标映射到\(e_t^i\) 。然后将这些向量连接起来，作为LSTM的输入。(这里需要注意的是在构建tensort时，当前考虑的行人的隐含状态是不包括在内的，此部分状态单独作为一部分输入到LSTM中，如图一所示) 上式中\(\phi\)为ReLU映射函数，\(W_e\) 和 \(W_a\) 为映射权重。 位置估计： 使用 \(t\) 时刻的隐含状态预测 \(t+1\) 时刻位置坐标的分布(\(\hat{x}\), \(\hat{y}\))\(_{t+1}^i\)。论文中使用的概率模型为二维高斯分布, (\(\hat{x}\), \(\hat{y}\))\(_{t}^i\) ~ \(\mathscr{N}(\mu^i_t,\sigma^i_t,\rho^i_t)\) 。其参数如下所示： 均值为 \(\mu^i_{t+1}=(\mu_x,\mu_y)^i_{t+1}\) 标准差为 \(\sigma^i_{t+1}=(\sigma_x,\sigma_y)^i_{t+1}\) 相关系数为 \(\rho^i_{t+1}\) 这些参数通过一个\(5 \times D\)的权重矩阵\(W_p\)线性得到： \[[\mu_t^i,\sigma^i_t,\rho^i_t] = W_p \times h_i^{t-1} \] LSTM 的参数通过最小化负数对数似然损失学得(\(L^i\)表示第 \(i\) 个人的轨迹): （这里左边括号中应该还包括\(W_a\), 原文中应该是漏掉了） 通过对训练集中所有的轨迹最小化这个损失学得参数。(论文中关于实现细节讲的很少，但是这篇文章公开了code.) 实验部分：选用的两个数据集分别是ETH 和 UCY, 使用三个不同的度量准则： 平均偏移错误(Average displacement error)。所有预测的坐标和真实的坐标之间的MSE。 最终偏移错误(Final displacement error)。模型预测的终点坐标和真实的终点坐标之间的差距。 非线性区域平均偏移错误(Average non-linear displacement error)。由于大部分错误都发生在转弯时，因此，文章专门衡量了在这些区域的错误率。 实验结果如下图所示(均为错误率)(本文的对比实验也比较充分)：]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
</search>
